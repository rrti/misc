import os
import sys
import random
import time

import hashlib
import base64

## BLOCK_ALPHABET  = range(ord('0'), ord('9') + 1)
BLOCK_ALPHABET  = [ord('+'), ord('-'), ord('*'), ord('/')]
BLOCK_ALPHABET += range(ord('A'), ord('Z') + 1)
BLOCK_ALPHABET += range(ord('a'), ord('z') + 1)

HSH_FUNC = hashlib.sha256
ENC_FUNC = base64.b64encode



## reads an unsigned integer from dev/urandom
## (the non-blocking PRNG entropy-pool) using
## <num_bytes> octets
def rnd_val(num_bytes):
	rnd_value = 0
	rnd_bytes = os.urandom(num_bytes)

	## work in base-256, LSB to MSB
	for i in xrange(num_bytes):
		rnd_octet = rnd_bytes[num_bytes - i - 1]
		rnd_value += (ord(rnd_octet) << (8 * i))
		## rnd_value += (ord(rnd_octet) * (256 ** i))

	return rnd_value

## returns a random integer in [min_bound, max_bound>
def rnd_idx(min_bound, max_bound, num_bytes = 4):
	rnd_value = rnd_val(num_bytes)
	rnd_limit = 1 << (num_bytes * 8)
	rnd_scale = (rnd_value * 1.0) / rnd_limit
	rnd_index = int(min_bound + (max_bound - min_bound) * rnd_scale)
	assert(rnd_value < rnd_limit)
	assert(rnd_index < max_bound)
	return rnd_index

def rnd_sel(elems):
	return elems[ rnd_idx(0, len(elems)) ]



def gen_permutations_rec(blocks, perms, indices, depth = 0):
	if (depth >= len(blocks)):
		## generate permutation based on permuted index-list
		permu = [blocks[i] for i in indices]
		perms.append((permu, indices[:]))
	else:
		for i in xrange(len(blocks)):
			if (i in indices):
				continue

			assert(indices[depth] == -1)

			indices[depth] = i
			gen_permutations_rec(blocks, perms, indices, depth + 1)
			indices[depth] = -1

	return perms

def gen_permutations(blocks):
	return (gen_permutations_rec(blocks, [], [-1] * len(blocks)))


def gen_password_block(block_size):
	block = [chr(random.choice(BLOCK_ALPHABET)) for i in xrange(block_size)]
	return block

def gen_password_blocks(num_blocks, block_size):
	blocks = [gen_password_block(block_size) for i in xrange(num_blocks)]
	return blocks

def gen_password_string(pw_blocks, pw_permus, perm_index):
	## pick the user's wanted block-permutation
	(pw_block_perm, pw_block_idx_perm) = pw_permus[perm_index % len(pw_permus)]

	assert(len(pw_block_perm) == len(pw_block_idx_perm))
	print("[gen_password_string] block_idx_perm=%s" % pw_block_idx_perm)

	## show user the blocks that should be memorized
	##
	## N blocks allow N! different passwords of equal
	## length and strength, user only has to remember
	## his chosen permutation order and seed)
	##
	## if the blocks are words pulled from a standard
	## language dictionary, this reduces to xkcd #936
	for i in xrange(len(pw_blocks)):
		print("\tblocks[%d]=\"%s\"" % (i, "".join(pw_blocks[i])))

	pw_string = ""

	for i in xrange(len(pw_block_perm)):
		## pw_string += ("%02d" % pw_block_idx_perm[i])
		pw_string += ("".join(pw_block_perm[i]))

	return pw_string



def gen_hash_chain_pw(arg_params):
	## always require a key-string, random value acts as salt
	if (arg_params["hash_str"] == ""):
		return -1

	if (arg_params["rng_seed"] != -1):
		random.seed(arg_params["rng_seed"])

		## if seed was user-specified, always generate rnd_value
		## and num_iters from it even if user provided those too
		##
		## (otherwise assume rnd_value and num_iters are already
		## randomly generated by user so we do not need the RNG)
		arg_params["rnd_value"] = random.randint((1 << 16), (1 << 32))
		arg_params["num_iters"] = random.randint((1 << 10), (1 << 20))

	rnd_value = arg_params["rnd_value"]
	num_iters = arg_params["num_iters"]
	num_bytes = arg_params["num_bytes"]

	## prepare the first round (e.g. hash("123456789|www.abc.com"))
	hash_object_alg = HSH_FUNC(str(rnd_value) + arg_params["hash_str"])
	hash_digest_enc = ENC_FUNC(hash_object_alg.digest())

	## hash-chain for a random number of iterations
	for i in xrange(num_iters):
		hash_object_alg = HSH_FUNC(hash_digest_enc)
		hash_digest_enc = ENC_FUNC(hash_object_alg.digest())

	## take substring of final hash as password
	print("[gen_hash_chain_pw][seed=%d][pass=\"%s\"]" % (arg_params["rng_seed"], hash_digest_enc[0: num_bytes]))
	return 0

def gen_block_perm_pw(arg_params):
	if (arg_params["rng_seed"] == -1):
		arg_params["rng_seed"] = int(time.time())

	random.seed(arg_params["rng_seed"])

	num_blocks = arg_params["num_blocks"]
	block_size = arg_params["block_size"]
	perm_index = arg_params["perm_index"]

	## do not let the pw become too weak
	num_blocks = max(3, num_blocks)
	block_size = max(3, block_size)

	## generate a list of random blocks, then permute it
	pw_blocks = gen_password_blocks(num_blocks, block_size)
	pw_permus = gen_permutations(pw_blocks)
	pw_string = gen_password_string(pw_blocks, pw_permus, perm_index)

	print("[gen_block_perm_pw][seed=%d][pass=\"%s\"]" % (arg_params["rng_seed"], pw_string))
	return 0



def parse_args(argc, argv):
	arg_params = {
		## which password-generator mode (function) to use
		"gen_mode": -1,
		## key-string to feed into first hash-chain round
		"hash_str": "",

		## this is normally user-specified
		"rng_seed": -1,

		## hash-chain method parameters
		"rnd_value": (1 << 24),
		"num_iters": (1 << 15),
		"num_bytes": 24,

		## block-permutation method parameters
		"num_blocks": 4,
		"block_size": 6,
		"perm_index": 0,
	}

	assert(argc == len(argv))
	try:
		for i in xrange(argc - 1):
			if (argv[i] == "--gen_mode"): arg_params["gen_mode"] = int(argv[i + 1]); continue
			if (argv[i] == "--hash_str"): arg_params["hash_str"] = str(argv[i + 1]); continue

			if (argv[i] == "--rng_seed"): arg_params["rng_seed"] = int(argv[i + 1]); continue

			if (argv[i] == "--rnd_value"): arg_params["rnd_value"] = int(argv[i + 1]); continue
			if (argv[i] == "--num_iters"): arg_params["num_iters"] = int(argv[i + 1]); continue
			if (argv[i] == "--num_bytes"): arg_params["num_bytes"] = int(argv[i + 1]); continue

			if (argv[i] == "--num_blocks"): arg_params["num_blocks"] = int(argv[i + 1]); continue
			if (argv[i] == "--block_size"): arg_params["block_size"] = int(argv[i + 1]); continue
			if (argv[i] == "--perm_index"): arg_params["perm_index"] = int(argv[i + 1]); continue
	except ValueError:
		pass

	return arg_params

def main(argc, argv):
	arg_params = parse_args(argc, argv)

	pw_gen_fncs = [gen_hash_chain_pw, gen_block_perm_pw]
	pw_gen_mode = arg_params["gen_mode"]

	if (pw_gen_mode >= 0 and pw_gen_mode < len(pw_gen_fncs)):
		return (pw_gen_fncs[pw_gen_mode](arg_params))

	print("[main] usage: python %s <--gen_mode 0|1> [args]" % argv[0])
	return -1

sys.exit(main(len(sys.argv), sys.argv))

