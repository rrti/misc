#include <stdio.h>
#include <string.h>

void f(const char* shcode) {
	// problem: since buffer lives on the stack, its memory
	// location will be different each invocation and would
	// need to be guessed based on value of %rbp (unless we
	// disable address space layout randomization)
	// overflowing past the end of a GLOBAL "static" buffer
	// will not overwrite return address since such buffers
	// obviously do not live on the stack
	//
	//   -0x40(%rbp) == &buffer[0] : $rbp-0x50+16 == rbp-64
	//   -0x48(%rbp) == &shcode[0] : passed in reg. %rdi and stored there
	//   -0x50(%rbp) == $rsp
	//
	// after "returning" to main (really to &buffer[0]):
	//   -0x10(%rbp) == &buffer[48] 8-byte scratch-space on stack ("rbp" before returning)
	//   -0x08(%rbp) == &buffer[56] 8-byte scratch-space on stack ("ret" before returning)
	//
	// disassemble main --> "0x401130: mov $0x0,%eax"
	// p *((unsigned long int*)($rbp + 8)) --> 4198704 (0x401130)
	//
	// [0xLO ...          ... 0xHI]
	// [...][buffer][rbp][ret][...]
	//
	char buffer[64] = {0};

	printf("[%s] &buffer[0]=%p shcode=%s (len=%lu)\n", __FUNCTION__, &buffer[0], shcode, strlen(shcode));

	// NOTE:
	//   "-2" because the actual ret-addr is not necessarily represented by
	//   8 bytes and anything following a zero-byte will not be passed along
	#if 1
	memcpy(buffer,                      shcode,                      sizeof(buffer)); // copy shellcode
	memcpy(buffer + 64 + sizeof(void*), shcode + 64 + sizeof(void*), sizeof(void*)-2); // overwrite retaddr (skip rbp, memcpy generates instrs referencing it)
	#else
	strcpy(buffer, shcode);
	#endif
}

int main(int argc, char** argv) {
	if (argc >= 2) {
		f(argv[1]);
	}

	return 0;
}

